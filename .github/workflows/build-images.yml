name: Build Raspberry Pi Images

on:
  push:
    branches:
      - '**'
  schedule:
    # Daily build at 2:00 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    # Allows manual trigger

env:
  DEBIAN_FRONTEND: noninteractive

jobs:
  # Job 1: Detect available images
  detect-images:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.list.outputs.images }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: List available images
        id: list
        run: |
          images=$(ls -d images/*/ | xargs -n 1 basename | jq -R -s -c 'split("\n")[:-1]')
          echo "images=$images" >> $GITHUB_OUTPUT
          echo "Detected images: $images"

  # Job 2: Stage 1 - Download and Prepare (parallel for all images)
  stage1-download:
    needs: detect-images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Free disk space
        run: |
          # Free up disk space for large images
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          df -h

      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -y \
            wget \
            genisoimage \
            xz-utils

      - name: Stage 1 - Download and prepare for ${{ matrix.image }}
        run: |
          ./bin/autobuild --image ${{ matrix.image }} --stage 1

      - name: Upload base images (cache)
        uses: actions/upload-artifact@v5
        with:
          name: base-images-${{ matrix.image }}
          path: |
            *.img
            *.raw
            images/${{ matrix.image }}/cloudinit/seed.img
            images/${{ matrix.image }}/setup.iso
          retention-days: 1

  # Job 3: Stage 2 - QEMU Setup (parallel for all images, most time-consuming)
  stage2-qemu:
    needs: [detect-images, stage1-download]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install QEMU dependencies
        run: |
          sudo apt update
          sudo apt install -y \
            qemu-system-aarch64 \
            qemu-utils \
            qemu-efi-aarch64

      - name: Download base images from stage 1
        uses: actions/download-artifact@v6
        with:
          name: base-images-${{ matrix.image }}

      - name: Stage 2 - QEMU setup for ${{ matrix.image }}
        run: |
          ./bin/autobuild --image ${{ matrix.image }} --stage 2
        timeout-minutes: 60

      - name: Upload Debian image after QEMU
        uses: actions/upload-artifact@v5
        with:
          name: debian-configured-${{ matrix.image }}
          path: |
            debian-13-arm64.raw
          retention-days: 1
          compression-level: 0

  # Job 4: Stage 3 - Build hybrid image (parallel for all images)
  stage3-build:
    needs: [detect-images, stage2-qemu]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install build dependencies
        run: |
          sudo apt update
          sudo apt install -y \
            parted \
            e2fsprogs \
            dosfstools \
            rsync \
            qemu-utils

      - name: Enable loop devices
        run: |
          # Load loop module
          sudo modprobe loop
          # Check available loop devices
          ls -la /dev/loop* || true

      - name: Download RaspiOS image from stage 1
        uses: actions/download-artifact@v6
        with:
          name: base-images-${{ matrix.image }}
          pattern: '*.img'

      - name: Download configured Debian image from stage 2
        uses: actions/download-artifact@v6
        with:
          name: debian-configured-${{ matrix.image }}

      - name: Stage 3 - Build hybrid image for ${{ matrix.image }}
        run: |
          ./bin/autobuild --image ${{ matrix.image }} --stage 3

      - name: Upload hybrid image
        uses: actions/upload-artifact@v5
        with:
          name: hybrid-image-${{ matrix.image }}
          path: |
            rpi-*.img
          retention-days: 1
          compression-level: 0

  # Job 5: Stage 4 - Compress (parallel for all images)
  stage4-compress:
    needs: [detect-images, stage3-build]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Install PiShrink
        run: |
          wget -q https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
          chmod +x pishrink.sh
          sudo mv pishrink.sh /usr/local/bin/

      - name: Download hybrid image from stage 3
        uses: actions/download-artifact@v6
        with:
          name: hybrid-image-${{ matrix.image }}

      - name: Stage 4 - Compress image for ${{ matrix.image }}
        run: |
          # Find the .img file for this image
          IMAGE_FILE=$(ls rpi-*.img)
          echo "Compressing $IMAGE_FILE"

          # Compress with PiShrink
          sudo pishrink.sh -aZ "$IMAGE_FILE"

      - name: Upload compressed image
        uses: actions/upload-artifact@v5
        with:
          name: final-image-${{ matrix.image }}
          path: |
            rpi-*.img.xz
          retention-days: 7

  # Job 6: Create Release
  create-release:
    needs: [detect-images, stage4-compress]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Download all compressed images
        uses: actions/download-artifact@v6
        with:
          pattern: final-image-*
          merge-multiple: true

      - name: List built images
        run: |
          echo "Created images:"
          ls -lh *.img.xz || true

      - name: Generate release name
        id: release_info
        run: |
          # Release name based on date
          RELEASE_DATE=$(date +'%Y-%m-%d')
          RELEASE_TIME=$(date +'%H%M')
          RELEASE_TAG="v${RELEASE_DATE}-${RELEASE_TIME}"
          RELEASE_NAME="Build ${RELEASE_DATE} ${RELEASE_TIME}"

          # Determine if it's a pre-release
          if [ "${{ github.ref_name }}" = "main" ]; then
            IS_PRERELEASE="false"
            RELEASE_NAME="Release ${RELEASE_DATE}"
          else
            IS_PRERELEASE="true"
            RELEASE_NAME="Pre-release ${RELEASE_DATE} (${GITHUB_REF_NAME})"
          fi

          echo "tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
          echo "prerelease=${IS_PRERELEASE}" >> $GITHUB_OUTPUT
          echo "date=${RELEASE_DATE}" >> $GITHUB_OUTPUT

      - name: Create Release and Upload Assets
        run: |
          # Create release body
          cat > release_body.md << 'EOF'
          ## ðŸš€ Raspberry Pi Hybrid Images - ${{ steps.release_info.outputs.date }}

          Raspberry Pi images with RaspiOS boot + Debian ARM64 rootfs.

          ### ðŸ“¦ Available Images

          All images in this release are ready to flash to SD/SSD.

          ### ðŸ“ Flash an Image

          ```bash
          # Decompress and flash
          xz -dc rpi-*.img.xz | sudo dd of=/dev/sdX bs=4M status=progress conv=fsync
          sync
          ```

          **âš ï¸ Replace `/dev/sdX` with your device!**

          ### ðŸ”§ Build Info

          - **Branch** : `${{ github.ref_name }}`
          - **Commit** : `${{ github.sha }}`
          - **Date** : `${{ steps.release_info.outputs.date }}`
          - **Workflow** : [Build #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ### ðŸ“š Documentation

          See [README.md](https://github.com/${{ github.repository }}/blob/${{ github.ref_name }}/README.md) for more information.
          EOF

          # Create release with .img.xz files
          PRERELEASE_FLAG=""
          if [ "${{ steps.release_info.outputs.prerelease }}" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          gh release create ${{ steps.release_info.outputs.tag }} \
            --title "${{ steps.release_info.outputs.name }}" \
            --notes-file release_body.md \
            $PRERELEASE_FLAG \
            *.img.xz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Cleanup
        if: always()
        run: |
          # Clean up large files
          sudo rm -f *.img *.img.xz *.raw *.iso
          df -h
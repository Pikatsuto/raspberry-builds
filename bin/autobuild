#!/bin/bash
set -e

# ============================================================================
# Automated multi-image build script
# 1. Download latest images
# 2. Launch QEMU with automatic setup
# 3. Build Raspberry Pi image
# 4. Compress with PiShrink
# ============================================================================

WORKDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$WORKDIR"

# Global configuration
RASPIOS_URL="https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2025-11-24/2025-11-24-raspios-trixie-arm64-lite.img.xz"
DEBIAN_URL="https://cloud.debian.org/images/cloud/trixie-backports/daily/latest/debian-13-backports-genericcloud-arm64-daily.raw"
RASPIOS_IMAGE="2025-11-24-raspios-trixie-arm64-lite.img"
DEBIAN_IMAGE="debian-13-arm64.raw"
DEBIAN_IMAGE_DOWNLOAD="debian-13-backports-genericcloud-arm64-daily.raw"

# Image variables (overridden by config.sh)
OUTPUT_IMAGE="pi5-custom.img"
QEMU_RAM="8G"
QEMU_CPUS="4"
IMAGE_SIZE="8G"
DESCRIPTION=""

# Control variables
CURRENT_IMAGE=""
BUILD_ALL_IMAGES=false
STAGE="all"

# Colors for display
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

echo_step() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} ${GREEN}$1${NC}"
}

echo_warn() {
    echo -e "${YELLOW}âš  $1${NC}"
}

echo_error() {
    echo -e "${RED}âœ— $1${NC}"
}

echo_success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

echo_info() {
    echo -e "${CYAN}â„¹ $1${NC}"
}

# List all available images
list_images() {
    echo_info "Available images:"
    for img_dir in images/*/; do
        if [ -d "$img_dir" ]; then
            img_name=$(basename "$img_dir")
            config_file="$img_dir/config.sh"

            if [ -f "$config_file" ]; then
                # Load config to display description
                source "$config_file"
                echo "  - $img_name${DESCRIPTION:+ : $DESCRIPTION}"
            else
                echo_warn "  - $img_name (no config.sh)"
            fi
        fi
    done
}

# Load image configuration
load_image_config() {
    local img_name="$1"
    local img_dir="images/$img_name"

    if [ ! -d "$img_dir" ]; then
        echo_error "Image '$img_name' not found in images/"
        echo ""
        list_images
        exit 1
    fi

    if [ ! -f "$img_dir/config.sh" ]; then
        echo_error "config.sh file missing for image '$img_name'"
        exit 1
    fi

    if [ ! -f "$img_dir/setup.sh" ]; then
        echo_error "setup.sh file missing for image '$img_name'"
        exit 1
    fi

    # Load configuration
    source "$img_dir/config.sh"

    CURRENT_IMAGE="$img_name"

    echo_info "Configuration for image '$img_name' loaded"
    echo "  Output: $OUTPUT_IMAGE"
    echo "  Size: $IMAGE_SIZE"
    echo "  QEMU RAM: $QEMU_RAM, CPUs: $QEMU_CPUS"
    [ -n "$DESCRIPTION" ] && echo "  Description: $DESCRIPTION"
}

# Check dependencies based on stage
check_dependencies() {
    local stage="$1"
    echo_step "Checking dependencies for stage $stage..."
    local missing=()
    local required_cmds=()

    # Determine required commands based on stage
    case "$stage" in
        "1")
            # Stage 1: Download and prepare
            required_cmds=(wget genisoimage)
            ;;
        "2")
            # Stage 2: QEMU setup
            required_cmds=(qemu-system-aarch64)
            ;;
        "3")
            # Stage 3: Build hybrid image
            required_cmds=(parted e2fsck resize2fs losetup rsync)
            ;;
        "4")
            # Stage 4: Compress
            # PiShrink will be checked separately
            ;;
        "all")
            # All stages: check all dependencies
            required_cmds=(wget qemu-system-aarch64 genisoimage parted e2fsck resize2fs losetup rsync)
            ;;
    esac

    # Check required commands
    for cmd in "${required_cmds[@]}"; do
        if ! command -v $cmd &> /dev/null; then
            missing+=($cmd)
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        echo_error "Missing dependencies for stage $stage: ${missing[*]}"
        echo ""
        echo "Install commands by stage:"
        echo "  Stage 1: sudo apt install -y wget genisoimage xz-utils"
        echo "  Stage 2: sudo apt install -y qemu-system-aarch64 qemu-utils qemu-efi-aarch64"
        echo "  Stage 3: sudo apt install -y parted e2fsprogs rsync qemu-utils"
        echo "  Stage 4: (PiShrink auto-installed if needed)"
        echo "  All:     sudo apt install -y wget qemu-system-aarch64 qemu-utils qemu-efi-aarch64 parted e2fsprogs dosfstools rsync xz-utils genisoimage"
        exit 1
    fi

    # Check PiShrink for stage 4 or all
    if [ "$stage" = "4" ] || [ "$stage" = "all" ]; then
        if ! command -v pishrink.sh &> /dev/null; then
            echo_warn "PiShrink not found. Installing..."
            wget -q https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh -O /tmp/pishrink.sh
            chmod +x /tmp/pishrink.sh
            sudo mv /tmp/pishrink.sh /usr/local/bin/
            echo_success "PiShrink installed"
        fi
    fi

    echo_success "All required dependencies for stage $stage are installed"
}

# Download base images
download_images() {
    local img_name="$1"
    local img_dir="images/$img_name"

    echo_step "Downloading base images..."

    # Raspberry Pi OS
    if [ ! -f "$RASPIOS_IMAGE" ]; then
        if [ ! -f "${RASPIOS_IMAGE}.xz" ]; then
            echo "  Downloading Raspberry Pi OS..."
            wget -c "$RASPIOS_URL" -O "${RASPIOS_IMAGE}.xz"
        fi
        echo "  Decompressing Raspberry Pi OS..."
        unxz -k "${RASPIOS_IMAGE}.xz"
        rm -f "${RASPIOS_IMAGE}.xz"
    else
        echo_success "Raspberry Pi OS already present"
    fi

    # Debian
    if [ ! -f "$DEBIAN_IMAGE_DOWNLOAD" ]; then
        echo "  Downloading Debian ARM64..."
        wget -c "$DEBIAN_URL" -O "$DEBIAN_IMAGE_DOWNLOAD"
    else
        echo_success "Debian ARM64 already present"
    fi

    echo "  Copying Debian ARM64 image..."
    rm -f "$DEBIAN_IMAGE"
    cp "$DEBIAN_IMAGE_DOWNLOAD" "$DEBIAN_IMAGE"

    # Regenerate cloud-init seed.img for this image
    if [ -d "$img_dir/cloudinit" ]; then
        echo "  Generating cloud-init seed.img for '$img_name'..."

        rm -f "$img_dir/cloudinit/seed.img"
        genisoimage -quiet -output "$img_dir/cloudinit/seed.img" \
            -volid cidata \
            -joliet -rock \
            "$img_dir/cloudinit/user-data" \
            "$img_dir/cloudinit/meta-data"
    else
        echo_error "No cloudinit/ in $img_dir, installation impossible"
        exit 1
    fi

    echo_success "Base images ready"
}

# Create setup.iso for an image
create_setup_iso() {
    local img_name="$1"
    local img_dir="images/$img_name"

    echo_step "Creating $img_dir/setup.iso for '$img_name'..."
    rm -f "$img_dir/setup.iso"

    # Verify files exist
    if [ ! -f "$img_dir/setup.sh" ]; then
        echo_error "$img_dir/setup.sh not found!"
        exit 1
    fi

    if [ ! -d "$img_dir/setupfiles" ]; then
        echo_warn "$img_dir/setupfiles/ not found, creating empty directory"
        mkdir -p "$img_dir/setupfiles"
    fi

    # Create temporary directory for ISO
    SETUP_ISO_DIR=$(mktemp -d)

    # Copy setup.sh as "setup" (without extension)
    cp "$img_dir/setup.sh" "$SETUP_ISO_DIR/setup"
    chmod +x "$SETUP_ISO_DIR/setup"

    # Copy setupfiles
    cp -r "$img_dir/setupfiles" "$SETUP_ISO_DIR/setupfiles"

    # Create ISO
    genisoimage -quiet -output "$img_dir/setup.iso" -volid "SETUP" -joliet -rock "$SETUP_ISO_DIR"/*

    # Cleanup
    rm -rf "$SETUP_ISO_DIR"

    echo_success "$img_dir/setup.iso created for '$img_name'"
}

# Launch QEMU with automatic setup
run_qemu_setup() {
    local img_name="$1"
    local img_dir="images/$img_name"

    echo_step "Launching QEMU for automatic setup..."
    echo "  Image: $CURRENT_IMAGE"
    echo "  RAM: $QEMU_RAM | CPUs: $QEMU_CPUS"
    echo "  Setup will execute automatically and QEMU will shut down"
    echo ""

    # Check UEFI firmware
    UEFI_BIOS=""
    if [ -f "/usr/share/edk2/aarch64/QEMU_CODE.fd" ]; then
        UEFI_BIOS="/usr/share/edk2/aarch64/QEMU_CODE.fd"
    elif [ -f "/usr/share/qemu-efi-aarch64/QEMU_EFI.fd" ]; then
        UEFI_BIOS="/usr/share/qemu-efi-aarch64/QEMU_EFI.fd"
    else
        echo_error "ARM64 UEFI firmware not found!"
        echo "Install with: sudo apt install qemu-efi-aarch64"
        exit 1
    fi

    # Launch QEMU
    qemu-system-aarch64 \
        -M virt \
        -cpu cortex-a72 \
        -m "$QEMU_RAM" \
        -smp "$QEMU_CPUS" \
        -bios "$UEFI_BIOS" \
        -drive file="$DEBIAN_IMAGE",format=raw,if=virtio \
        -drive file="$img_dir/cloudinit/seed.img",format=raw,if=virtio \
        -drive file="$img_dir/setup.iso",format=raw,if=virtio,readonly=on \
        -device virtio-net-pci,netdev=net0 \
        -netdev user,id=net0 \
        -nographic

    echo_step "Cleaning up temporary files..."
    rm -f "$img_dir/setup.iso" "$img_dir/cloudinit/seed.img"
    echo_success "Cleanup completed"

    echo ""
    echo_success "QEMU finished - Setup completed for '$CURRENT_IMAGE'"
}

# Build Raspberry Pi image
build_rpi_image() {
    echo_step "Creating hybrid Raspberry Pi image..."
    echo "  Output: $OUTPUT_IMAGE"
    echo "  Size: $IMAGE_SIZE"

    ./bin/merge-debian-raspios.sh \
        -o "$OUTPUT_IMAGE" \
        -s "$IMAGE_SIZE" \
        "$RASPIOS_IMAGE" \
        "$DEBIAN_IMAGE"

    rm -f "$DEBIAN_IMAGE"

    echo_success "Hybrid image created: $OUTPUT_IMAGE"
}

# Compress with PiShrink
compress_image() {
    echo_step "Compressing image with PiShrink..."

    # PiShrink requires sudo
    sudo rm -f "$OUTPUT_IMAGE.xz"
    sudo pishrink.sh -aZ "$OUTPUT_IMAGE"

    COMPRESSED="${OUTPUT_IMAGE}.xz"
    if [ -f "$COMPRESSED" ]; then
        SIZE_ORIGINAL=$(du -h "$OUTPUT_IMAGE" 2>/dev/null | cut -f1 || echo "N/A")
        SIZE_COMPRESSED=$(du -h "$COMPRESSED" | cut -f1)
        echo_success "Image compressed: $COMPRESSED"
        echo "  Original size  : $SIZE_ORIGINAL"
        echo "  Compressed size: $SIZE_COMPRESSED"
    else
        echo_error "Compression failed"
        exit 1
    fi
}

# Build a single image (with stage support)
build_image() {
    local img_name="$1"

    echo ""
    cat << EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              Building image: $img_name (Stage: $STAGE)
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo ""

    load_image_config "$img_name"

    # Stage 1: Download + Create setup.iso
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "1" ]; then
        echo_step "=== STAGE 1: Download and Prepare ==="
        if [ "$SKIP_DOWNLOAD" = false ]; then
            download_images "$img_name"
        else
            echo_warn "Skipping base images download"
        fi
        create_setup_iso "$img_name"
    fi

    # Stage 2: QEMU Setup
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "2" ]; then
        echo_step "=== STAGE 2: QEMU Setup ==="
        if [ "$SKIP_QEMU" = false ]; then
            run_qemu_setup "$img_name"
        else
            echo_warn "Skipping QEMU - using existing Debian image"
        fi
    fi

    # Stage 3: Build RPi image
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "3" ]; then
        echo_step "=== STAGE 3: Build Raspberry Pi Image ==="
        build_rpi_image
    fi

    # Stage 4: Compress
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "4" ]; then
        echo_step "=== STAGE 4: Compress ==="
        if [ "$SKIP_COMPRESS" = false ]; then
            compress_image
        else
            echo_warn "Skipping PiShrink compression"
        fi
    fi

    # Summary
    echo ""
    if [ "$STAGE" = "all" ]; then
        cat << EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           BUILD COMPLETED: $img_name âœ“
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    else
        cat << EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           STAGE $STAGE COMPLETED: $img_name âœ“
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    fi

    echo ""
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "4" ]; then
        echo_success "Final image:"
        if [ "$SKIP_COMPRESS" = false ]; then
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}.xz"
        else
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}"
        fi
    elif [ "$STAGE" = "3" ]; then
        echo_success "Uncompressed image:"
        echo "  ðŸ“¦ ${OUTPUT_IMAGE}"
    fi
    echo ""
}

# Build all images
build_all_images() {
    echo ""
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         Building ALL available images                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

    local images=()
    for img_dir in images/*/; do
        if [ -d "$img_dir" ] && [ -f "$img_dir/config.sh" ]; then
            images+=($(basename "$img_dir"))
        fi
    done

    if [ ${#images[@]} -eq 0 ]; then
        echo_error "No images found in images/"
        exit 1
    fi

    echo_info "Images to build: ${images[*]}"
    echo ""

    local total=${#images[@]}
    local current=0

    for img in "${images[@]}"; do
        current=$((current + 1))
        echo ""
        echo_info "[$current/$total] Building image '$img'..."
        build_image "$img"
        echo ""
    done

    echo ""
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      ALL BUILDS COMPLETED SUCCESSFULLY âœ“                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo ""
    echo_success "Images created:"
    for img in "${images[@]}"; do
        load_image_config "$img" > /dev/null
        if [ "$SKIP_COMPRESS" = false ]; then
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}.xz"
        else
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}"
        fi
    done
    echo ""
}

# Options menu
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Automated build of Raspberry Pi images with custom Debian rootfs

Options:
    --image NAME        Build a specific image
    --all-images        Build all available images
    --list-images       List available images
    --stage STAGE       Run specific stage (1, 2, 3, 4, or all; default: all)

    --skip-download     Don't download base images
    --skip-qemu         Don't launch QEMU (use existing Debian image)
    --skip-compress     Don't compress with PiShrink

    --help              Display this help

Build Stages:
    Stage 1: Download base images + Create setup.iso
    Stage 2: Run QEMU setup (installs packages, configures system)
    Stage 3: Build hybrid Raspberry Pi image (merge RaspiOS + Debian)
    Stage 4: Compress with PiShrink

Examples:
    # List available images
    $0 --list-images

    # Build a specific image (all stages)
    $0 --image exemple

    # Build all images
    $0 --all-images

    # Build only stage 1 (download and prepare)
    $0 --image exemple --stage 1

    # Build only stage 2 (QEMU setup) - requires stage 1 completed
    $0 --image exemple --stage 2

    # Build stages 3+4 (merge + compress) - requires stages 1-2 completed
    $0 --image exemple --stage 3
    $0 --image exemple --stage 4

    # Build an image without downloading base images
    $0 --image exemple --skip-download

    # Build all images without compression
    $0 --all-images --skip-compress

Image structure:
    images/image-name/
    â”œâ”€â”€ config.sh       # Configuration (size, RAM, etc.)
    â”œâ”€â”€ setup.sh        # Script executed in QEMU
    â”œâ”€â”€ setupfiles/     # Files copied to the image
    â””â”€â”€ cloudinit/      # Cloud-init configuration
        â”œâ”€â”€ user-data
        â”œâ”€â”€ meta-data
        â””â”€â”€ seed.img    # Generated automatically

To create a new image:
    cp -r images/exemple images/my-image
    # Edit images/my-image/config.sh and setup.sh
    $0 --image my-image

EOF
    exit 0
}

# Parse arguments
SKIP_DOWNLOAD=false
SKIP_QEMU=false
SKIP_COMPRESS=false
IMAGE_NAME=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --image)
            IMAGE_NAME="$2"
            shift 2
            ;;
        --all-images)
            BUILD_ALL_IMAGES=true
            shift
            ;;
        --list-images)
            list_images
            exit 0
            ;;
        --stage)
            STAGE="$2"
            if [[ ! "$STAGE" =~ ^(1|2|3|4|all)$ ]]; then
                echo_error "Invalid stage: $STAGE (must be 1, 2, 3, 4, or all)"
                exit 1
            fi
            shift 2
            ;;
        --skip-download)
            SKIP_DOWNLOAD=true
            shift
            ;;
        --skip-qemu)
            SKIP_QEMU=true
            shift
            ;;
        --skip-compress)
            SKIP_COMPRESS=true
            shift
            ;;
        --help|-h)
            show_usage
            ;;
        *)
            echo_error "Unknown option: $1"
            show_usage
            ;;
    esac
done

# Validate arguments
if [ "$BUILD_ALL_IMAGES" = true ] && [ -n "$IMAGE_NAME" ]; then
    echo_error "You cannot use --image and --all-images at the same time"
    exit 1
fi

if [ "$BUILD_ALL_IMAGES" = false ] && [ -z "$IMAGE_NAME" ]; then
    echo_error "You must specify --image or --all-images"
    echo ""
    show_usage
fi

# Banner
cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         Automated Build - Raspberry Pi + Debian         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

echo ""

# Execute workflow
check_dependencies "$STAGE"

if [ "$BUILD_ALL_IMAGES" = true ]; then
    build_all_images
else
    build_image "$IMAGE_NAME"
fi

# Flashing instructions
echo "To flash to SD/SSD:"
if [ "$SKIP_COMPRESS" = false ]; then
    echo "  xz -dc ${OUTPUT_IMAGE}.xz | sudo dd of=/dev/sdX bs=4M status=progress conv=fsync"
else
    echo "  sudo dd if=${OUTPUT_IMAGE} of=/dev/sdX bs=4M status=progress conv=fsync"
fi
echo "  sync"
echo ""
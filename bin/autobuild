#!/bin/bash
set -e

# ============================================================================
# Automated multi-image build script
# 1. Download latest images
# 2. Launch QEMU with automatic setup
# 3. Build Raspberry Pi image
# 4. Compress with PiShrink
# ============================================================================

WORKDIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$WORKDIR"

# Global configuration
RASPIOS_URL="https://downloads.raspberrypi.com/raspios_lite_arm64/images/raspios_lite_arm64-2025-11-24/2025-11-24-raspios-trixie-arm64-lite.img.xz"
RASPIOS_IMAGE="2025-11-24-raspios-trixie-arm64-lite.img"
DISTRO_IMAGE="distro-arm64.raw"

# Image variables (overridden by config.sh)
OUTPUT_IMAGE="pi5-custom.img"
QEMU_RAM="8G"
QEMU_CPUS="4"
IMAGE_SIZE="8G"
DESCRIPTION=""
CLOUD=true
IMAGE_URL=""

# Control variables
CURRENT_IMAGE=""
BUILD_ALL_IMAGES=false
STAGE="all"
TEMP_IMAGE_DIR=""  # Temporary directory for dynamic images
QEMU_LOG_FILE=""   # QEMU log file for error detection

# Colors for display
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

echo_step() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} ${GREEN}$1${NC}"
}

echo_warn() {
    echo -e "${YELLOW}âš  $1${NC}"
}

echo_error() {
    echo -e "${RED}âœ— $1${NC}"
}

echo_success() {
    echo -e "${GREEN}âœ“ $1${NC}"
}

echo_info() {
    echo -e "${CYAN}â„¹ $1${NC}"
}

# List all available images
list_images() {
    echo_info "Available images:"
    echo ""

    # List distro directories
    for distro_dir in images/*/; do
        if [ ! -d "$distro_dir" ]; then
            continue
        fi

        local DISTRO=$(basename "$distro_dir")

        # Skip non-distro directories
        if [ ! -f "${distro_dir}config.sh" ]; then
            continue
        fi

        # Load distro config
        source "${distro_dir}config.sh"
        echo "  ${DISTRO}${DESCRIPTION:+ : $DESCRIPTION}"

        # Get base services defined in config (these are always included)
        local BASE_SERVICES="$SERVICES"

        # List available services for this distro
        if [ -d "${distro_dir}services" ]; then
            local SERVICES_LIST=""
            for service_dir in ${distro_dir}services/*/; do
                if [ -d "$service_dir" ]; then
                    local SERVICE_NAME=$(basename "$service_dir")

                    # Skip services that are in BASE_SERVICES (always included)
                    if [[ " $BASE_SERVICES " =~ " $SERVICE_NAME " ]]; then
                        continue
                    fi

                    SERVICES_LIST="${SERVICES_LIST}${SERVICE_NAME} "
                fi
            done

            if [ -n "$SERVICES_LIST" ]; then
                echo "    Available services: $(echo $SERVICES_LIST | tr ' ' ', ' | sed 's/, $//')"
                echo "    Build with: ./bin/autobuild --image ${DISTRO}/service1+service2+..."
            fi
        fi

        # List pre-configured legacy images in distro (skip services/ subdirectory and support directories)
        local HAS_LEGACY=false
        for img_dir in ${distro_dir}*/; do
            if [ ! -d "$img_dir" ]; then
                continue
            fi

            local IMG_SUBDIR=$(basename "$img_dir")

            # Skip special directories (services, cloudinit, setupfiles, first-boot)
            if [[ "$IMG_SUBDIR" =~ ^(services|cloudinit|setupfiles|first-boot)$ ]]; then
                continue
            fi

            local CONFIG_FILE="${img_dir}config.sh"

            # Only list if config.sh exists
            if [ -f "$CONFIG_FILE" ]; then
                if [ "$HAS_LEGACY" = false ]; then
                    echo "    Legacy images:"
                    HAS_LEGACY=true
                fi

                # Load config to display description
                source "$CONFIG_FILE"
                echo "      - ${IMG_SUBDIR}${DESCRIPTION:+ : $DESCRIPTION}"
            fi
        done

        echo ""
    done

    echo_info "Dynamic image format examples:"
    echo "  ./bin/autobuild --image debian                     # Base debian"
    echo "  ./bin/autobuild --image debian/qemu+haos           # Debian with qemu and haos services"
    echo ""
}

# Parse image name to extract distro and services
# Format: distro/service1+service2 or distro-service1+service2
parse_image_name() {
    local img_name="$1"
    local DISTRO=""
    local SERVICES=""
    local IMG_BASE_NAME=""

    # Check if format is distro/services
    if [[ "$img_name" == *"/"* ]]; then
        DISTRO=$(echo "$img_name" | cut -d'/' -f1)
        local services_part=$(echo "$img_name" | cut -d'/' -f2)

        # Convert + to spaces for SERVICES variable
        SERVICES=$(echo "$services_part" | tr '+' ' ')
        IMG_BASE_NAME="$DISTRO-$(echo "$services_part" | tr '+' '-')"
    else
        # No slash - check if it's just a distro name or has services
        # If it contains '-' followed by what looks like services, parse it
        if [[ "$img_name" == *"-"* ]]; then
            # Try to detect if this is distro-services format
            local first_part=$(echo "$img_name" | cut -d'-' -f1)

            # Check if first part is a known distro
            if [ -d "images/$first_part/services" ]; then
                DISTRO="$first_part"
                local services_part=$(echo "$img_name" | cut -d'-' -f2-)
                SERVICES=$(echo "$services_part" | tr '+' ' ')
                IMG_BASE_NAME="$img_name"
            else
                # Not a known distro, assume it's a custom name with default distro (debian)
                DISTRO="debian"
                # Extract services part (everything after first -)
                local services_part=$(echo "$img_name" | sed 's/^[^-]*-//')
                SERVICES=$(echo "$services_part" | tr '+' ' ')
                IMG_BASE_NAME="$img_name"
            fi
        else
            # Just a plain name, no services - assume it's a distro or legacy image
            DISTRO="$img_name"
            SERVICES=""
            IMG_BASE_NAME="$img_name"
        fi
    fi

    echo "$DISTRO|$SERVICES|$IMG_BASE_NAME"
}

# Load image configuration
load_image_config() {
    local img_name="$1"
    local img_dir="images/$img_name"

    # First, check if physical directory exists (legacy mode)
    if [ -d "$img_dir" ] && [ -f "$img_dir/config.sh" ]; then
        # Legacy mode: physical directory with config
        echo_info "Loading configuration from $img_dir/config.sh"
        source "$img_dir/config.sh"

        # Check if setup.sh exists (only for legacy mode)
        MODE=$(detect_services_mode "$img_name")
        if [ "$MODE" = "legacy" ] && [ ! -f "$img_dir/setup.sh" ]; then
            echo_error "setup.sh file missing for image '$img_name'"
            exit 1
        fi

        CURRENT_IMAGE="$img_name"

        echo_info "Configuration for image '$img_name' loaded"
        echo "  Output: $OUTPUT_IMAGE"
        echo "  Size: $IMAGE_SIZE"
        echo "  QEMU RAM: $QEMU_RAM, CPUs: $QEMU_CPUS"
        [ -n "$DESCRIPTION" ] && echo "  Description: $DESCRIPTION"
        return
    fi

    # Parse image name for dynamic service composition
    local parsed=$(parse_image_name "$img_name")
    local DISTRO=$(echo "$parsed" | cut -d'|' -f1)
    local PARSED_SERVICES=$(echo "$parsed" | cut -d'|' -f2)
    local IMG_BASE_NAME=$(echo "$parsed" | cut -d'|' -f3)

    # Check if distro exists
    if [ ! -d "images/$DISTRO" ]; then
        echo_error "Distribution '$DISTRO' not found in images/"
        echo ""
        list_images
        exit 1
    fi

    # Check if distro has a base config
    if [ ! -f "images/$DISTRO/config.sh" ]; then
        echo_error "config.sh missing for distribution '$DISTRO'"
        exit 1
    fi

    # Load base distro config
    echo_info "Loading base configuration from images/$DISTRO/config.sh"
    source "images/$DISTRO/config.sh"

    # Save base services (always included)
    local BASE_SERVICES="$SERVICES"

    # Override with dynamic services if specified
    if [ -n "$PARSED_SERVICES" ]; then
        echo_info "Building dynamic image with services: $PARSED_SERVICES"

        # Verify all services exist
        for service in $PARSED_SERVICES; do
            if [ ! -d "images/$DISTRO/services/$service" ]; then
                echo_error "Service '$service' not found in images/$DISTRO/services/"
                exit 1
            fi
        done

        # Combine base services with user-specified services
        # Remove duplicates while preserving order (base services first)
        local ALL_SERVICES=""
        local SEEN_SERVICES=""

        # Add base services first
        for service in $BASE_SERVICES; do
            ALL_SERVICES="$ALL_SERVICES$service "
            SEEN_SERVICES="$SEEN_SERVICES$service "
        done

        # Add user services (skip if already in base)
        for service in $PARSED_SERVICES; do
            if [[ ! " $SEEN_SERVICES " =~ " $service " ]]; then
                ALL_SERVICES="$ALL_SERVICES$service "
            fi
        done

        # Set final SERVICES variable (trim trailing space)
        SERVICES=$(echo "$ALL_SERVICES" | xargs)

        # Generate output image name if not custom
        OUTPUT_IMAGE="${IMG_BASE_NAME}.img"
        DESCRIPTION="$DISTRO with services: $(echo $PARSED_SERVICES | tr ' ' '+')"
    fi

    # Create virtual image directory for dynamic builds in /tmp
    # Use short prefix to avoid mktemp template length issues with long image names
    TEMP_IMAGE_DIR=$(mktemp -d -t "rpi-build-${IMG_BASE_NAME}.XXXXXX")
    img_dir="$TEMP_IMAGE_DIR"

    echo_info "Using temporary directory: $TEMP_IMAGE_DIR (for $IMG_BASE_NAME)"

    # Create virtual config.sh in the temporary directory
    cat > "$img_dir/config.sh" << EOF
# Auto-generated config for dynamic image build
OUTPUT_IMAGE="$OUTPUT_IMAGE"
IMAGE_SIZE="$IMAGE_SIZE"
QEMU_RAM="$QEMU_RAM"
QEMU_CPUS="$QEMU_CPUS"
CLOUD=$CLOUD
IMAGE_URL="$IMAGE_URL"
SERVICES="$SERVICES"
DESCRIPTION="$DESCRIPTION"
EOF

    CURRENT_IMAGE="$img_name"

    echo_info "Dynamic configuration for image '$img_name' created"
    echo "  Distro: $DISTRO"
    echo "  Services: ${SERVICES:-none}"
    echo "  Output: $OUTPUT_IMAGE"
    echo "  Size: $IMAGE_SIZE"
    echo "  QEMU RAM: $QEMU_RAM, CPUs: $QEMU_CPUS"
    [ -n "$DESCRIPTION" ] && echo "  Description: $DESCRIPTION"
}

# Check dependencies based on stage
check_dependencies() {
    local stage="$1"
    echo_step "Checking dependencies for stage $stage..."
    local missing=()
    local required_cmds=()

    # Determine required commands based on stage
    case "$stage" in
        "1")
            # Stage 1: Download and prepare
            required_cmds=(wget genisoimage)
            ;;
        "2")
            # Stage 2: QEMU setup
            required_cmds=(qemu-system-aarch64)
            ;;
        "3")
            # Stage 3: Build hybrid image
            required_cmds=(parted e2fsck resize2fs losetup rsync)
            ;;
        "4")
            # Stage 4: Compress
            # PiShrink will be checked separately
            ;;
        "all")
            # All stages: check all dependencies
            required_cmds=(wget qemu-system-aarch64 genisoimage parted e2fsck resize2fs losetup rsync)
            ;;
    esac

    # Check required commands
    for cmd in "${required_cmds[@]}"; do
        if ! command -v $cmd &> /dev/null; then
            missing+=($cmd)
        fi
    done

    if [ ${#missing[@]} -ne 0 ]; then
        echo_error "Missing dependencies for stage $stage: ${missing[*]}"
        echo ""
        echo "Install commands by stage:"
        echo "  Stage 1: sudo apt install -y wget genisoimage xz-utils"
        echo "  Stage 2: sudo apt install -y qemu-system-aarch64 qemu-utils qemu-efi-aarch64"
        echo "  Stage 3: sudo apt install -y parted e2fsprogs rsync qemu-utils"
        echo "  Stage 4: (PiShrink auto-installed if needed)"
        echo "  All:     sudo apt install -y wget qemu-system-aarch64 qemu-utils qemu-efi-aarch64 parted e2fsprogs dosfstools rsync xz-utils genisoimage"
        exit 1
    fi

    # Check PiShrink for stage 4 or all
    if [ "$stage" = "4" ] || [ "$stage" = "all" ]; then
        if ! command -v pishrink.sh &> /dev/null; then
            echo_warn "PiShrink not found. Installing..."
            wget -q https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh -O /tmp/pishrink.sh
            chmod +x /tmp/pishrink.sh
            sudo mv /tmp/pishrink.sh /usr/local/bin/
            echo_success "PiShrink installed"
        fi
    fi

    echo_success "All required dependencies for stage $stage are installed"
}

# Detect boot mode from CLOUD variable in config.sh
detect_boot_mode() {
    if [ "$CLOUD" = true ]; then
        echo "cloudinit"
    else
        echo "firstboot"
    fi
}

# Inject first-boot service into distro image (for CLOUD=false)
inject_firstboot_service() {
    local IMG_NAME="$1"
    local IMG_DIR="images/$IMG_NAME"
    local DISTRO=$(echo "$IMG_NAME" | cut -d'/' -f1)
    local FIRSTBOOT_DIR="images/$DISTRO/first-boot"

    echo "  Injecting first-boot service into distribution image..."

    # Verify first-boot files exist in distro directory
    if [ ! -f "$FIRSTBOOT_DIR/setup-runner.sh" ] || [ ! -f "$FIRSTBOOT_DIR/setup-runner.service" ]; then
        echo_error "Missing files in $FIRSTBOOT_DIR/"
        echo "Required: setup-runner.sh, setup-runner.service"
        exit 1
    fi

    # Find partition in distro image
    LOOP_DEV=$(sudo losetup -fP --show "$DISTRO_IMAGE")

    # Detect rootfs partition (ext4 filesystem)
    ROOT_PART=""
    for part in ${LOOP_DEV}p*; do
        if [ -b "$part" ]; then
            FS_TYPE=$(sudo blkid -s TYPE -o value "$part" 2>/dev/null || true)
            if [ "$FS_TYPE" = "ext4" ]; then
                ROOT_PART="$part"
                echo "  Found rootfs on $(basename $part) (ext4)"
                break
            fi
        fi
    done

    if [ -z "$ROOT_PART" ]; then
        echo_error "Cannot find ext4 rootfs partition in $DISTRO_IMAGE"
        sudo losetup -d "$LOOP_DEV"
        exit 1
    fi

    # Mount image
    MOUNT_DIR=$(mktemp -d)
    sudo mount "$ROOT_PART" "$MOUNT_DIR"

    # Copy first-boot files
    sudo cp "$FIRSTBOOT_DIR/setup-runner.sh" "$MOUNT_DIR/root/setup-runner.sh"
    sudo chmod +x "$MOUNT_DIR/root/setup-runner.sh"
    sudo cp "$FIRSTBOOT_DIR/setup-runner.service" "$MOUNT_DIR/etc/systemd/system/setup-runner.service"

    # Enable service using chroot
    sudo chroot "$MOUNT_DIR" systemctl enable setup-runner.service 2>/dev/null || true

    # Cleanup
    sudo umount "$MOUNT_DIR"
    sudo losetup -d "$LOOP_DEV"
    rm -rf "$MOUNT_DIR"

    echo_success "First-boot service injected and enabled"
}

# Download base images
download_images() {
    local IMG_NAME="$1"
    local IMG_DIR=$(get_image_dir "$IMG_NAME")

    # Parse image name to get distro
    local parsed=$(parse_image_name "$IMG_NAME")
    local DISTRO=$(echo "$parsed" | cut -d'|' -f1)
    local DISTRO_DIR="images/$DISTRO"

    echo_step "Downloading base images..."

    # Raspberry Pi OS
    if [ ! -f "$RASPIOS_IMAGE" ]; then
        if [ ! -f "${RASPIOS_IMAGE}.xz" ]; then
            echo "  Downloading Raspberry Pi OS..."
            wget -c "$RASPIOS_URL" -O "${RASPIOS_IMAGE}.xz"
        fi
        echo "  Decompressing Raspberry Pi OS..."
        unxz -k "${RASPIOS_IMAGE}.xz"
        rm -f "${RASPIOS_IMAGE}.xz"
    else
        echo_success "Raspberry Pi OS already present"
    fi

    # Get IMAGE_URL from config
    if [ -z "$IMAGE_URL" ]; then
        echo_error "IMAGE_URL not defined in config.sh"
        exit 1
    fi

    # Determine download filename from URL
    DOWNLOAD_FILENAME=$(basename "$IMAGE_URL")

    # Download distribution image if needed
    if [ ! -f "$DOWNLOAD_FILENAME" ]; then
        echo "  Downloading base distribution image from IMAGE_URL..."
        wget -c "$IMAGE_URL" -O "$DOWNLOAD_FILENAME"
    else
        echo_success "Base distribution image already present ($DOWNLOAD_FILENAME)"
    fi

    # Copy to working image
    echo "  Copying base distribution image to $DISTRO_IMAGE..."
    rm -f "$DISTRO_IMAGE"
    cp "$DOWNLOAD_FILENAME" "$DISTRO_IMAGE"

    # Detect boot mode from CLOUD variable
    BOOT_MODE=$(detect_boot_mode)
    echo "  Boot mode: $BOOT_MODE (CLOUD=$CLOUD)"

    if [ "$BOOT_MODE" = "cloudinit" ]; then
        echo "  Using cloud-init boot mode..."

        # For dynamic images, use cloudinit from distro base directory
        # For legacy images, use cloudinit from image directory
        local CLOUDINIT_DIR=""
        if [ -d "$IMG_DIR/cloudinit" ]; then
            # Legacy image with its own cloudinit
            CLOUDINIT_DIR="$IMG_DIR/cloudinit"
        elif [ -d "$DISTRO_DIR/cloudinit" ]; then
            # Dynamic image - use distro's cloudinit
            CLOUDINIT_DIR="$DISTRO_DIR/cloudinit"
            echo "  Using cloud-init from distro: $DISTRO_DIR/cloudinit"
        else
            echo_error "CLOUD=true but no cloudinit directory found"
            echo "  Checked: $IMG_DIR/cloudinit and $DISTRO_DIR/cloudinit"
            exit 1
        fi

        echo "  Generating cloud-init seed.img..."
        # For dynamic images, store seed.img in distro directory (persistent across stages)
        # For legacy images, store in image directory
        local SEED_IMG_PATH="$CLOUDINIT_DIR/seed.img"
        rm -f "$SEED_IMG_PATH"
        genisoimage -quiet -output "$SEED_IMG_PATH" \
            -volid cidata \
            -joliet -rock \
            "$CLOUDINIT_DIR/user-data" \
            "$CLOUDINIT_DIR/meta-data"
        echo_success "cloud-init seed.img generated at $SEED_IMG_PATH"
    else
        echo "  Using first-boot service mode (no cloud-init)..."
        inject_firstboot_service "$IMG_NAME"
    fi

    echo_success "Base images ready"
}

# Get the correct image directory (temp for dynamic, images/ for legacy)
get_image_dir() {
    local img_name="$1"

    # If TEMP_IMAGE_DIR is set (dynamic image), use it
    if [ -n "$TEMP_IMAGE_DIR" ] && [ -d "$TEMP_IMAGE_DIR" ]; then
        echo "$TEMP_IMAGE_DIR"
    else
        # Legacy image
        echo "images/$img_name"
    fi
}

# Detect if image uses services system
detect_services_mode() {
    local img_name="$1"
    local img_dir=$(get_image_dir "$img_name")

    # Check if config.sh defines SERVICES variable
    if [ -f "$img_dir/config.sh" ]; then
        if grep -q "^SERVICES=" "$img_dir/config.sh"; then
            echo "services"
            return
        fi
    fi

    echo "legacy"
}

# Build setup from modular services
build_services_setup() {
    local img_name="$1"
    local img_dir=$(get_image_dir "$img_name")

    echo_step "Building setup from modular services for '$img_name'..."

    # Load SERVICES from config.sh
    source "$img_dir/config.sh"

    if [ -z "$SERVICES" ]; then
        echo_error "SERVICES variable not defined in config.sh"
        exit 1
    fi

    echo "  Services to combine: $SERVICES"

    # Determine distro from image name (supports both legacy and dynamic formats)
    local parsed=$(parse_image_name "$img_name")
    local distro=$(echo "$parsed" | cut -d'|' -f1)
    local services_dir="images/$distro/services"

    if [ ! -d "$services_dir" ]; then
        echo_error "Services directory not found: $services_dir"
        exit 1
    fi

    echo "  Using services from: $services_dir"

    # Resolve service dependencies and order them correctly
    # Order: base services -> their dependencies -> additional requested services
    local final_services=""
    local processed_services=""

    # Helper function to recursively resolve dependencies in correct order
    resolve_dependencies() {
        local service="$1"

        # Skip if already processed
        if echo " $processed_services " | grep -q " $service "; then
            return
        fi

        # Check if service exists
        if [ ! -d "$services_dir/$service" ]; then
            echo_error "Service '$service' not found in $services_dir"
            exit 1
        fi

        # Load dependencies if exists
        local depends_file="$services_dir/$service/depends.sh"
        local DEPENDS_ON=""

        if [ -f "$depends_file" ]; then
            source "$depends_file"
        fi

        # First, recursively resolve all dependencies
        if [ -n "$DEPENDS_ON" ]; then
            echo "  Service '$service' depends on: $DEPENDS_ON"
            for dep in $DEPENDS_ON; do
                resolve_dependencies "$dep"
            done
        fi

        # Then add this service (after all its dependencies)
        processed_services="$processed_services $service"
        final_services="$final_services $service"
    }

    # Process all services in order: base services first, then additional ones
    for service in $SERVICES; do
        resolve_dependencies "$service"
    done

    # Remove leading/trailing spaces and update SERVICES
    SERVICES=$(echo "$final_services" | xargs)
    echo "  Final service list with dependencies: $SERVICES"

    # Create temporary directory for combined setup
    COMBINED_DIR=$(mktemp -d)
    mkdir -p "$COMBINED_DIR/setupfiles"

    # Initialize combined setup.sh
    cat > "$COMBINED_DIR/setup.sh" << 'EOF'
#!/bin/bash
set -e

# ============================================================================
# Auto-generated setup script from modular services
# ============================================================================

echo "======================================"
echo "Starting rootfs configuration"
echo "======================================"

EOF

    # Combine setup.sh from each service
    for service in $SERVICES; do
        service_path="$services_dir/$service"

        if [ ! -d "$service_path" ]; then
            echo_error "Service '$service' not found in $services_dir"
            rm -rf "$COMBINED_DIR"
            exit 1
        fi

        if [ -f "$service_path/setup.sh" ]; then
            echo "  Adding service: $service"

            # Append service setup (skip shebang and set -e lines)
            tail -n +3 "$service_path/setup.sh" >> "$COMBINED_DIR/setup.sh"
            echo "" >> "$COMBINED_DIR/setup.sh"
        fi

        # Copy setupfiles from service
        if [ -d "$service_path/setupfiles" ]; then
            cp -r "$service_path/setupfiles/"* "$COMBINED_DIR/setupfiles/" 2>/dev/null || true
        fi

        # Copy motd.sh to motd.d if it exists
        if [ -f "$service_path/motd.sh" ]; then
            mkdir -p "$COMBINED_DIR/setupfiles/motd.d"
            cp "$service_path/motd.sh" "$COMBINED_DIR/setupfiles/motd.d/${service}.sh" 2>/dev/null || true
        fi
    done

    # Add cleanup and completion at the end
    cat >> "$COMBINED_DIR/setup.sh" << 'EOF'

# Cleanup
echo "Cleaning up..."
apt autoremove -y --purge
apt clean
rm -rf /var/lib/apt/lists/*

# Create flag file to indicate setup is complete
echo "Finalizing..."
touch /root/setup-completed
date > /root/setup-completed

echo "======================================"
echo "Configuration completed successfully!"
echo "======================================"
EOF

    # Build services-first-boot.sh from service first-boot scripts
    SERVICES_FIRSTBOOT="$COMBINED_DIR/setupfiles/services-first-boot.sh"

    if [ -f "$services_dir/base/setupfiles/services-first-boot.sh" ]; then
        cp "$services_dir/base/setupfiles/services-first-boot.sh" "$SERVICES_FIRSTBOOT"
    else
        echo_error "Base services-first-boot.sh not found in $services_dir/base/setupfiles/"
        rm -rf "$COMBINED_DIR"
        exit 1
    fi

    # Inject first-boot init scripts from services
    for service in $SERVICES; do
        service_firstboot="$services_dir/$service/first-boot/init.sh"

        if [ -f "$service_firstboot" ]; then
            echo "  Adding first-boot init: $service"

            # Create a temporary file with the service header and content
            SERVICE_CONTENT=$(mktemp)
            echo "" >> "$SERVICE_CONTENT"
            echo "# ------ $service service ------" >> "$SERVICE_CONTENT"
            cat "$service_firstboot" >> "$SERVICE_CONTENT"
            echo "" >> "$SERVICE_CONTENT"

            # Insert before END marker using a more robust method
            awk -v content="$SERVICE_CONTENT" '
                /# ====== END SERVICES INITIALIZATION ======/ {
                    while ((getline line < content) > 0) {
                        print line
                    }
                    close(content)
                }
                { print }
            ' "$SERVICES_FIRSTBOOT" > "${SERVICES_FIRSTBOOT}.tmp"

            mv "${SERVICES_FIRSTBOOT}.tmp" "$SERVICES_FIRSTBOOT"
            rm -f "$SERVICE_CONTENT"
        fi
    done

    # Copy generated files to image directory
    mkdir -p "$img_dir"
    cp "$COMBINED_DIR/setup.sh" "$img_dir/setup.sh"
    rm -rf "$img_dir/setupfiles"
    cp -r "$COMBINED_DIR/setupfiles" "$img_dir/setupfiles"

    # Cleanup
    rm -rf "$COMBINED_DIR"

    echo_success "Setup built from services: $SERVICES"
}

# Create setup.iso for an image
create_setup_iso() {
    local img_name="$1"
    local img_dir=$(get_image_dir "$img_name")

    # Parse image name to get distro (for persistent path)
    local parsed=$(parse_image_name "$img_name")
    local DISTRO=$(echo "$parsed" | cut -d'|' -f1)
    local DISTRO_DIR="images/$DISTRO"

    # Check if image uses services system
    MODE=$(detect_services_mode "$img_name")

    if [ "$MODE" = "services" ]; then
        build_services_setup "$img_name"
    fi

    # For dynamic images, store setup.iso in distro directory (persistent across stages)
    # For legacy images, store in image directory
    local SETUP_ISO_PATH=""
    if [ -n "$TEMP_IMAGE_DIR" ] && [ -d "$TEMP_IMAGE_DIR" ]; then
        # Dynamic image - use distro directory
        SETUP_ISO_PATH="$DISTRO_DIR/setup.iso"
        echo_step "Creating $DISTRO_DIR/setup.iso for '$img_name'..."
    else
        # Legacy image - use image directory
        SETUP_ISO_PATH="$img_dir/setup.iso"
        echo_step "Creating $img_dir/setup.iso for '$img_name'..."
    fi

    rm -f "$SETUP_ISO_PATH"

    # Verify files exist
    if [ ! -f "$img_dir/setup.sh" ]; then
        echo_error "$img_dir/setup.sh not found!"
        exit 1
    fi

    if [ ! -d "$img_dir/setupfiles" ]; then
        echo_warn "$img_dir/setupfiles/ not found, creating empty directory"
        mkdir -p "$img_dir/setupfiles"
    fi

    # Create temporary directory for ISO
    SETUP_ISO_DIR=$(mktemp -d)

    # Copy setup.sh as "setup" (without extension)
    cp "$img_dir/setup.sh" "$SETUP_ISO_DIR/setup"
    chmod +x "$SETUP_ISO_DIR/setup"

    # Copy setupfiles
    cp -r "$img_dir/setupfiles" "$SETUP_ISO_DIR/setupfiles"

    # Create ISO (use -graft-points to preserve directory structure)
    genisoimage -quiet -output "$SETUP_ISO_PATH" -volid "SETUP" -joliet -rock -graft-points \
        /setup="$SETUP_ISO_DIR/setup" \
        /setupfiles="$SETUP_ISO_DIR/setupfiles"

    # Cleanup
    rm -rf "$SETUP_ISO_DIR"

    echo_success "setup.iso created at $SETUP_ISO_PATH for '$img_name'"
}

# Launch QEMU with automatic setup
run_qemu_setup() {
    local img_name="$1"
    local img_dir=$(get_image_dir "$img_name")

    # Parse image name to get distro (for resolving persistent paths)
    local parsed=$(parse_image_name "$img_name")
    local DISTRO=$(echo "$parsed" | cut -d'|' -f1)
    local DISTRO_DIR="images/$DISTRO"

    echo_step "Launching QEMU for automatic setup..."
    echo "  Image: $CURRENT_IMAGE"
    echo "  RAM: $QEMU_RAM | CPUs: $QEMU_CPUS"

    # Detect boot mode
    BOOT_MODE=$(detect_boot_mode "$img_name")
    echo "  Boot mode: $BOOT_MODE"
    echo "  Setup will execute automatically and QEMU will shut down"
    echo ""

    # Check UEFI firmware
    UEFI_BIOS=""
    if [ -f "/usr/share/edk2/aarch64/QEMU_CODE.fd" ]; then
        UEFI_BIOS="/usr/share/edk2/aarch64/QEMU_CODE.fd"
    elif [ -f "/usr/share/qemu-efi-aarch64/QEMU_EFI.fd" ]; then
        UEFI_BIOS="/usr/share/qemu-efi-aarch64/QEMU_EFI.fd"
    else
        echo_error "ARM64 UEFI firmware not found!"
        echo "Install with: sudo apt install qemu-efi-aarch64"
        exit 1
    fi

    # Resize distro image to final size for package installations
    echo_step "Resizing distribution image for package installation..."
    QEMU_IMAGE_SIZE="$IMAGE_SIZE"  # Use final image size from config.sh

    echo "  Current image size: $(du -h "$DISTRO_IMAGE" | cut -f1)"
    qemu-img resize "$DISTRO_IMAGE" "$QEMU_IMAGE_SIZE"
    echo "  Image resized to: $QEMU_IMAGE_SIZE"

    # Expand partition and filesystem
    echo "  Expanding partition and filesystem..."
    LOOP_DEV=$(sudo losetup -fP --show "$DISTRO_IMAGE")

    # Detect rootfs partition (ext4 filesystem)
    ROOTFS_PART=""
    PART_NUM=""
    for part in ${LOOP_DEV}p*; do
        if [ -b "$part" ]; then
            FS_TYPE=$(sudo blkid -s TYPE -o value "$part" 2>/dev/null || true)
            if [ "$FS_TYPE" = "ext4" ]; then
                ROOTFS_PART="$part"
                PART_NUM=$(echo "$part" | grep -o 'p[0-9]*$' | sed 's/p//')
                echo "  Found rootfs on partition $PART_NUM (ext4)"
                break
            fi
        fi
    done

    if [ -z "$ROOTFS_PART" ]; then
        echo_error "Cannot find ext4 rootfs partition!"
        sudo losetup -d "$LOOP_DEV"
        exit 1
    fi

    # Check if EFI partition exists and needs to be moved
    if [ -b "${LOOP_DEV}p2" ] && [ "$PART_NUM" = "1" ]; then
        echo "  Detected EFI partition p2, relocating to end of disk..."

        # Get exact size of original EFI partition
        EFI_SIZE_SECTORS=$(sudo blockdev --getsz "${LOOP_DEV}p2")
        EFI_SIZE_BYTES=$(sudo blockdev --getsize64 "${LOOP_DEV}p2")
        EFI_SIZE_MB=$((EFI_SIZE_BYTES / 1024 / 1024))
        echo "  Original EFI partition size: ${EFI_SIZE_MB}MB (${EFI_SIZE_SECTORS} sectors)"

        # Backup EFI partition (bit-for-bit copy)
        EFI_BACKUP=$(mktemp)
        echo "  Creating bit-for-bit backup of EFI partition..."
        sudo dd if="${LOOP_DEV}p2" of="$EFI_BACKUP" bs=1M status=none
        echo "  EFI partition backed up to temporary file"

        # Get total disk size
        DISK_SIZE_BYTES=$(sudo blockdev --getsize64 "$LOOP_DEV")
        DISK_SIZE_MB=$((DISK_SIZE_BYTES / 1024 / 1024))

        # Calculate new partition boundaries (leave exact space for EFI at the end)
        ROOTFS_END_MB=$((DISK_SIZE_MB - EFI_SIZE_MB - 1))
        EFI_START_MB=$((ROOTFS_END_MB + 1))

        echo "  Disk layout: rootfs 0-${ROOTFS_END_MB}MB, EFI ${EFI_START_MB}MB-${DISK_SIZE_MB}MB"

        # Remove EFI partition
        echo "  Removing old EFI partition..."
        sudo parted --script "$LOOP_DEV" rm 2 2>/dev/null || true

        # Resize rootfs partition to leave space for EFI
        echo "  Resizing rootfs to ${ROOTFS_END_MB}MB..."
        sudo parted --script "$LOOP_DEV" resizepart 1 ${ROOTFS_END_MB}MB 2>/dev/null || true

        # Recreate EFI partition at the end with exact original size
        echo "  Recreating EFI partition at end with original size..."
        sudo parted --script "$LOOP_DEV" mkpart primary fat32 ${EFI_START_MB}MB 100% 2>/dev/null || true
        sudo parted --script "$LOOP_DEV" set 2 esp on 2>/dev/null || true

        # Reload partition table
        sudo partprobe "$LOOP_DEV" 2>/dev/null || true
        sleep 1

        # Restore EFI partition (bit-for-bit restore)
        echo "  Restoring EFI partition from backup..."
        sudo dd if="$EFI_BACKUP" of="${LOOP_DEV}p2" bs=1M status=none
        rm -f "$EFI_BACKUP"
        echo "  EFI partition restored successfully"

        echo "  EFI partition relocated successfully"
    else
        # No EFI partition or rootfs is not p1, simple resize
        echo "  Resizing partition $PART_NUM to 100%..."
        sudo parted --script "$LOOP_DEV" resizepart "$PART_NUM" 100% 2>/dev/null || true
    fi

    # Resize ext4 filesystem (force non-interactive mode)
    echo "  Checking and resizing ext4 filesystem..."
    sudo e2fsck -fp "$ROOTFS_PART" || true
    sudo resize2fs "$ROOTFS_PART"

    # Cleanup
    sudo losetup -d "$LOOP_DEV"
    echo_success "Distribution image resized successfully"
    echo ""

    # Resolve paths for seed.img and setup.iso
    # For dynamic images, these are stored in the distro directory (persistent across stages)
    # For legacy images, they are in the image directory
    local SEED_IMG_PATH=""
    local SETUP_ISO_PATH=""

    if [ "$BOOT_MODE" = "cloudinit" ]; then
        # Determine seed.img path
        if [ -f "$img_dir/cloudinit/seed.img" ]; then
            # Legacy image
            SEED_IMG_PATH="$img_dir/cloudinit/seed.img"
        elif [ -f "$DISTRO_DIR/cloudinit/seed.img" ]; then
            # Dynamic image - use distro's seed.img
            SEED_IMG_PATH="$DISTRO_DIR/cloudinit/seed.img"
        else
            echo_error "seed.img not found!"
            echo "  Checked: $img_dir/cloudinit/seed.img and $DISTRO_DIR/cloudinit/seed.img"
            exit 1
        fi
        echo "  Using seed.img: $SEED_IMG_PATH"
    fi

    # Determine setup.iso path (for both modes)
    # For dynamic images, setup.iso should be in distro directory
    # For legacy images, it's in the image directory
    if [ -f "$img_dir/setup.iso" ]; then
        SETUP_ISO_PATH="$img_dir/setup.iso"
    elif [ -f "$DISTRO_DIR/setup.iso" ]; then
        SETUP_ISO_PATH="$DISTRO_DIR/setup.iso"
    else
        echo_error "setup.iso not found!"
        echo "  Checked: $img_dir/setup.iso and $DISTRO_DIR/setup.iso"
        exit 1
    fi
    echo "  Using setup.iso: $SETUP_ISO_PATH"

    # Launch QEMU with appropriate drives based on boot mode
    # Note: || true prevents script exit on QEMU errors (we only check /root/setup-completed)
    if [ "$BOOT_MODE" = "cloudinit" ]; then
        # Cloud-init mode: mount both seed.img and setup.iso
        qemu-system-aarch64 \
            -M virt \
            -cpu cortex-a72 \
            -m "$QEMU_RAM" \
            -smp "$QEMU_CPUS" \
            -bios "$UEFI_BIOS" \
            -drive file="$DISTRO_IMAGE",format=raw,if=virtio \
            -drive file="$SEED_IMG_PATH",format=raw,if=virtio \
            -drive file="$SETUP_ISO_PATH",format=raw,if=virtio,readonly=on \
            -device virtio-net-pci,netdev=net0 \
            -netdev user,id=net0 \
            -nographic || true
    elif [ "$BOOT_MODE" = "firstboot" ]; then
        # First-boot mode: mount only setup.iso (service is already injected)
        qemu-system-aarch64 \
            -M virt \
            -cpu cortex-a72 \
            -m "$QEMU_RAM" \
            -smp "$QEMU_CPUS" \
            -bios "$UEFI_BIOS" \
            -drive file="$DISTRO_IMAGE",format=raw,if=virtio \
            -drive file="$SETUP_ISO_PATH",format=raw,if=virtio,readonly=on \
            -device virtio-net-pci,netdev=net0 \
            -netdev user,id=net0 \
            -nographic || true
    else
        echo_error "Unknown boot mode: $BOOT_MODE"
        exit 1
    fi

    # Verify setup completed successfully
    echo_step "Verifying setup completion..."
    LOOP_DEV=$(sudo losetup -fP --show "$DISTRO_IMAGE")

    # Find rootfs partition
    ROOT_PART=""
    for part in ${LOOP_DEV}p*; do
        if [ -b "$part" ]; then
            FS_TYPE=$(sudo blkid -s TYPE -o value "$part" 2>/dev/null || true)
            if [ "$FS_TYPE" = "ext4" ]; then
                ROOT_PART="$part"
                break
            fi
        fi
    done

    if [ -z "$ROOT_PART" ]; then
        echo_error "Cannot find rootfs partition for verification!"
        sudo losetup -d "$LOOP_DEV"
        exit 1
    fi

    # Mount and check for completion flag
    MOUNT_DIR=$(mktemp -d)
    sudo mount "$ROOT_PART" "$MOUNT_DIR"
    SETUP_COMPLETED=false

    if sudo test -f "$MOUNT_DIR/root/setup-completed"; then
        SETUP_COMPLETED=true
        echo_success "Setup completed flag found"
    fi

    sudo umount "$MOUNT_DIR"
    sudo losetup -d "$LOOP_DEV"
    rm -rf "$MOUNT_DIR"

    # Handle setup failure
    if [ "$SETUP_COMPLETED" = false ]; then
        echo_error "QEMU setup failed!"
        echo_error "Setup completion flag not found at /root/setup-completed"
        echo_error "The setup.sh script did not run to completion."
        exit 1
    fi

    echo_step "Cleaning up temporary files..."
    rm -f "$img_dir/setup.iso"
    [ "$BOOT_MODE" = "cloudinit" ] && rm -f "$img_dir/cloudinit/seed.img"
    echo_success "Cleanup completed"

    echo ""
    echo_success "QEMU finished - Setup completed successfully for '$CURRENT_IMAGE'"
}

# Build Raspberry Pi image
build_rpi_image() {
    echo_step "Creating hybrid Raspberry Pi image..."
    echo "  Output: $OUTPUT_IMAGE"
    echo "  Size: $IMAGE_SIZE"

    ./bin/merge-debian-raspios.sh \
        -o "$OUTPUT_IMAGE" \
        -s "$IMAGE_SIZE" \
        "$RASPIOS_IMAGE" \
        "$DISTRO_IMAGE"

    rm -f "$DISTRO_IMAGE"

    echo_success "Hybrid image created: $OUTPUT_IMAGE"
}

# Compress with PiShrink
compress_image() {
    echo_step "Compressing image with PiShrink..."

    # PiShrink requires sudo
    sudo rm -f "$OUTPUT_IMAGE.xz"
    sudo pishrink.sh -aZ "$OUTPUT_IMAGE"

    COMPRESSED="${OUTPUT_IMAGE}.xz"
    if [ -f "$COMPRESSED" ]; then
        SIZE_ORIGINAL=$(du -h "$OUTPUT_IMAGE" 2>/dev/null | cut -f1 || echo "N/A")
        SIZE_COMPRESSED=$(du -h "$COMPRESSED" | cut -f1)
        echo_success "Image compressed: $COMPRESSED"
        echo "  Original size  : $SIZE_ORIGINAL"
        echo "  Compressed size: $SIZE_COMPRESSED"
    else
        echo_error "Compression failed"
        exit 1
    fi
}

# Build a single image (with stage support)
build_image() {
    local img_name="$1"

    echo ""
    cat << EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              Building image: $img_name (Stage: $STAGE)
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo ""

    load_image_config "$img_name"

    # Stage 1: Download + Create setup.iso
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "1" ]; then
        echo_step "=== STAGE 1: Download and Prepare ==="
        if [ "$SKIP_DOWNLOAD" = false ]; then
            download_images "$img_name"
        else
            echo_warn "Skipping base images download"
        fi
        create_setup_iso "$img_name"
    fi

    # Stage 2: QEMU Setup
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "2" ]; then
        echo_step "=== STAGE 2: QEMU Setup ==="
        if [ "$SKIP_QEMU" = false ]; then
            run_qemu_setup "$img_name"
        else
            echo_warn "Skipping QEMU - using existing Debian image"
        fi
    fi

    # Stage 3: Build RPi image
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "3" ]; then
        echo_step "=== STAGE 3: Build Raspberry Pi Image ==="
        build_rpi_image
    fi

    # Stage 4: Compress
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "4" ]; then
        echo_step "=== STAGE 4: Compress ==="
        if [ "$SKIP_COMPRESS" = false ]; then
            compress_image
        else
            echo_warn "Skipping PiShrink compression"
        fi
    fi

    # Summary
    echo ""
    if [ "$STAGE" = "all" ]; then
        cat << EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           BUILD COMPLETED: $img_name âœ“
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    else
        cat << EOF
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           STAGE $STAGE COMPLETED: $img_name âœ“
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    fi

    echo ""
    if [ "$STAGE" = "all" ] || [ "$STAGE" = "4" ]; then
        echo_success "Final image:"
        if [ "$SKIP_COMPRESS" = false ]; then
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}.xz"
        else
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}"
        fi
    elif [ "$STAGE" = "3" ]; then
        echo_success "Uncompressed image:"
        echo "  ðŸ“¦ ${OUTPUT_IMAGE}"
    fi
    echo ""

    # Cleanup temporary directory if it exists
    if [ -n "$TEMP_IMAGE_DIR" ] && [ -d "$TEMP_IMAGE_DIR" ]; then
        echo_step "Cleaning up temporary directory..."
        rm -rf "$TEMP_IMAGE_DIR"
        TEMP_IMAGE_DIR=""
        echo_success "Temporary directory removed"
    fi
}

# Build all images
build_all_images() {
    echo ""
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         Building ALL available images                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

    local images=()
    for img_dir in images/*/; do
        if [ -d "$img_dir" ] && [ -f "$img_dir/config.sh" ]; then
            images+=($(basename "$img_dir"))
        fi
    done

    if [ ${#images[@]} -eq 0 ]; then
        echo_error "No images found in images/"
        exit 1
    fi

    echo_info "Images to build: ${images[*]}"
    echo ""

    local total=${#images[@]}
    local current=0

    for img in "${images[@]}"; do
        current=$((current + 1))
        echo ""
        echo_info "[$current/$total] Building image '$img'..."
        build_image "$img"
        echo ""
    done

    echo ""
    cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘      ALL BUILDS COMPLETED SUCCESSFULLY âœ“                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF
    echo ""
    echo_success "Images created:"
    for img in "${images[@]}"; do
        load_image_config "$img" > /dev/null
        if [ "$SKIP_COMPRESS" = false ]; then
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}.xz"
        else
            echo "  ðŸ“¦ ${OUTPUT_IMAGE}"
        fi
    done
    echo ""
}

# Options menu
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS]

Automated build of Raspberry Pi images with custom Debian rootfs

Options:
    --image NAME        Build a specific image
    --all-images        Build all available images
    --list-images       List available images
    --stage STAGE       Run specific stage (1, 2, 3, 4, or all; default: all)

    --skip-download     Don't download base images
    --skip-qemu         Don't launch QEMU (use existing Debian image)
    --skip-compress     Don't compress with PiShrink

    --help              Display this help

Build Stages:
    Stage 1: Download base images + Create setup.iso
    Stage 2: Run QEMU setup (installs packages, configures system)
    Stage 3: Build hybrid Raspberry Pi image (merge RaspiOS + Debian)
    Stage 4: Compress with PiShrink

Examples:
    # List available images
    $0 --list-images

    # Build a specific image (all stages)
    $0 --image exemple

    # Build all images
    $0 --all-images

    # Build only stage 1 (download and prepare)
    $0 --image exemple --stage 1

    # Build only stage 2 (QEMU setup) - requires stage 1 completed
    $0 --image exemple --stage 2

    # Build stages 3+4 (merge + compress) - requires stages 1-2 completed
    $0 --image exemple --stage 3
    $0 --image exemple --stage 4

    # Build an image without downloading base images
    $0 --image exemple --skip-download

    # Build all images without compression
    $0 --all-images --skip-compress

Image structure (cloud-init mode):
    images/image-name/
    â”œâ”€â”€ config.sh       # Configuration (size, RAM, etc.)
    â”œâ”€â”€ setup.sh        # Script executed in QEMU
    â”œâ”€â”€ setupfiles/     # Files copied to the image
    â””â”€â”€ cloudinit/      # Cloud-init configuration
        â”œâ”€â”€ user-data
        â”œâ”€â”€ meta-data
        â””â”€â”€ seed.img    # Generated automatically

Image structure (first-boot mode):
    images/image-name/
    â”œâ”€â”€ config.sh           # Configuration (size, RAM, etc.)
    â”œâ”€â”€ setup.sh            # Script executed in QEMU
    â”œâ”€â”€ setupfiles/         # Files copied to the image
    â””â”€â”€ first-boot/         # First-boot service (no cloud-init)
        â”œâ”€â”€ setup-runner.sh
        â””â”€â”€ setup-runner.service

To create a new image:
    cp -r images/exemple images/my-image
    # Edit images/my-image/config.sh and setup.sh
    $0 --image my-image

EOF
    exit 0
}

# Parse arguments
SKIP_DOWNLOAD=false
SKIP_QEMU=false
SKIP_COMPRESS=false
IMAGE_NAME=""

while [[ $# -gt 0 ]]; do
    case $1 in
        --image)
            IMAGE_NAME="$2"
            shift 2
            ;;
        --all-images)
            BUILD_ALL_IMAGES=true
            shift
            ;;
        --list-images)
            list_images
            exit 0
            ;;
        --stage)
            STAGE="$2"
            if [[ ! "$STAGE" =~ ^(1|2|3|4|all)$ ]]; then
                echo_error "Invalid stage: $STAGE (must be 1, 2, 3, 4, or all)"
                exit 1
            fi
            shift 2
            ;;
        --skip-download)
            SKIP_DOWNLOAD=true
            shift
            ;;
        --skip-qemu)
            SKIP_QEMU=true
            shift
            ;;
        --skip-compress)
            SKIP_COMPRESS=true
            shift
            ;;
        --help|-h)
            show_usage
            ;;
        *)
            echo_error "Unknown option: $1"
            show_usage
            ;;
    esac
done

# Validate arguments
if [ "$BUILD_ALL_IMAGES" = true ] && [ -n "$IMAGE_NAME" ]; then
    echo_error "You cannot use --image and --all-images at the same time"
    exit 1
fi

if [ "$BUILD_ALL_IMAGES" = false ] && [ -z "$IMAGE_NAME" ]; then
    echo_error "You must specify --image or --all-images"
    echo ""
    show_usage
fi

# Banner
cat << "EOF"
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘         Automated Build - Raspberry Pi + Debian         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EOF

echo ""

# Execute workflow
check_dependencies "$STAGE"

if [ "$BUILD_ALL_IMAGES" = true ]; then
    build_all_images
else
    build_image "$IMAGE_NAME"
fi

# Flashing instructions
echo "To flash to SD/SSD:"
if [ "$SKIP_COMPRESS" = false ]; then
    echo "  xz -dc ${OUTPUT_IMAGE}.xz | sudo dd of=/dev/sdX bs=4M status=progress conv=fsync"
else
    echo "  sudo dd if=${OUTPUT_IMAGE} of=/dev/sdX bs=4M status=progress conv=fsync"
fi
echo "  sync"
echo ""
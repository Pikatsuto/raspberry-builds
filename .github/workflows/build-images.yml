name: Build Raspberry Pi Images

on:
  push:
    branches:
      - '**'
  schedule:
    # Daily build at 2:00 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    # Allows manual trigger

env:
  DEBIAN_FRONTEND: noninteractive

jobs:
  # Job 1: Detect available images
  detect-images:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.list.outputs.images }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: List available images from .github/images.txt
        id: list
        run: |
          # Read images from .github/images.txt, filter out comments and empty lines
          images=$(grep -v '^#' .github/images.txt | grep -v '^$' | jq -R -s -c 'split("\n")[:-1]')
          echo "images=$images" >> $GITHUB_OUTPUT
          echo "Images to build:"
          grep -v '^#' .github/images.txt | grep -v '^$'

  # Job 2: Stage 1 - Download and Prepare (parallel for all images)
  stage1-download:
    needs: detect-images
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Generate sanitized artifact name
        id: artifact
        run: |
          # Replace / and + with - for artifact names
          SANITIZED=$(echo "${{ matrix.image }}" | tr '/+' '--')
          echo "name=${SANITIZED}" >> $GITHUB_OUTPUT
          echo "Artifact name: ${SANITIZED}"

      - name: Free disk space
        run: |
          # Free up disk space for large images
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force
          df -h

      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -y \
            wget \
            genisoimage \
            xz-utils

      - name: Stage 1 - Download and prepare for ${{ matrix.image }}
        run: |
          ./bin/autobuild --image "${{ matrix.image }}" --stage 1

      - name: Upload base images (cache)
        uses: actions/upload-artifact@v5
        with:
          name: base-images-${{ steps.artifact.outputs.name }}
          path: |
            *.img
            *.raw
            images/${{ matrix.image }}/cloudinit/seed.img
            images/${{ matrix.image }}/setup.iso
          retention-days: 1

  # Job 3: Stage 2 - QEMU Setup (parallel for all images, most time-consuming)
  stage2-qemu:
    needs: [detect-images, stage1-download]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
      fail-fast: false
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Generate sanitized artifact name
        id: artifact
        run: |
          # Replace / and + with - for artifact names
          SANITIZED=$(echo "${{ matrix.image }}" | tr '/+' '--')
          echo "name=${SANITIZED}" >> $GITHUB_OUTPUT

      - name: Install QEMU dependencies
        run: |
          sudo apt update
          sudo apt install -y \
            qemu-system-aarch64 \
            qemu-utils \
            qemu-efi-aarch64

      - name: Download base images from stage 1
        uses: actions/download-artifact@v6
        with:
          name: base-images-${{ steps.artifact.outputs.name }}

      - name: Stage 2 - QEMU setup for ${{ matrix.image }}
        run: |
          ./bin/autobuild --image "${{ matrix.image }}" --stage 2
        timeout-minutes: 60

      - name: Upload Debian image after QEMU
        uses: actions/upload-artifact@v5
        with:
          name: distro-configured-${{ steps.artifact.outputs.name }}
          path: |
            distro-arm64.raw
          retention-days: 1
          compression-level: 0

  # Job 4: Stage 3 - Build hybrid image (parallel for all images)
  stage3-build:
    needs: [detect-images, stage2-qemu]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Generate sanitized artifact name
        id: artifact
        run: |
          # Replace / and + with - for artifact names
          SANITIZED=$(echo "${{ matrix.image }}" | tr '/+' '--')
          echo "name=${SANITIZED}" >> $GITHUB_OUTPUT

      - name: Install build dependencies
        run: |
          sudo apt update
          sudo apt install -y \
            parted \
            e2fsprogs \
            dosfstools \
            rsync \
            qemu-utils

      - name: Enable loop devices
        run: |
          # Load loop module
          sudo modprobe loop
          # Check available loop devices
          ls -la /dev/loop* || true

      - name: Download RaspiOS image from stage 1
        uses: actions/download-artifact@v6
        with:
          name: base-images-${{ steps.artifact.outputs.name }}
          pattern: '*.img'

      - name: Download configured distro image from stage 2
        uses: actions/download-artifact@v6
        with:
          name: distro-configured-${{ steps.artifact.outputs.name }}

      - name: Stage 3 - Build hybrid image for ${{ matrix.image }}
        run: |
          ./bin/autobuild --image "${{ matrix.image }}" --stage 3

      - name: Upload hybrid image
        uses: actions/upload-artifact@v5
        with:
          name: hybrid-image-${{ steps.artifact.outputs.name }}
          path: |
            *.img
          retention-days: 1
          compression-level: 0

  # Job 5: Stage 4 - Compress (parallel for all images)
  stage4-compress:
    needs: [detect-images, stage3-build]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-images.outputs.images) }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Generate sanitized artifact name
        id: artifact
        run: |
          # Replace / and + with - for artifact names
          SANITIZED=$(echo "${{ matrix.image }}" | tr '/+' '--')
          echo "name=${SANITIZED}" >> $GITHUB_OUTPUT

      - name: Install PiShrink
        run: |
          wget -q https://raw.githubusercontent.com/Drewsif/PiShrink/master/pishrink.sh
          chmod +x pishrink.sh
          sudo mv pishrink.sh /usr/local/bin/

      - name: Download hybrid image from stage 3
        uses: actions/download-artifact@v6
        with:
          name: hybrid-image-${{ steps.artifact.outputs.name }}

      - name: Stage 4 - Compress image for ${{ matrix.image }}
        run: |
          # Find the .img file for this image
          IMAGE_FILE=$(ls *.img | head -1)
          echo "Compressing $IMAGE_FILE"

          # Compress with PiShrink
          sudo pishrink.sh -aZ "$IMAGE_FILE"

      - name: Upload compressed image
        uses: actions/upload-artifact@v5
        with:
          name: final-image-${{ steps.artifact.outputs.name }}
          path: |
            *.img.xz
          retention-days: 7

  # Job 6: Create Release
  create-release:
    needs: [detect-images, stage4-compress]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Fetch all history for changelog generation

      - name: Download all compressed images
        uses: actions/download-artifact@v6
        with:
          pattern: final-image-*
          merge-multiple: true

      - name: List built images
        run: |
          echo "Created images:"
          ls -lh *.img.xz || true

      - name: Determine build type
        id: build_type
        run: |
          if [ "${{ github.event_name }}" = "schedule" ]; then
            echo "type=cron" >> $GITHUB_OUTPUT
            echo "ðŸ• Cron build detected - will update existing release"
          elif [ "${{ github.event_name }}" = "push" ]; then
            echo "type=push" >> $GITHUB_OUTPUT
            echo "ðŸ“ Push build detected - will create new release with changelog"
          else
            echo "type=manual" >> $GITHUB_OUTPUT
            echo "ðŸ”§ Manual build detected - will create new release"
          fi

      - name: Generate release name and tag
        id: release_info
        run: |
          RELEASE_DATE=$(date +'%Y-%m-%d')
          RELEASE_TIME=$(date +'%H%M')

          # Determine if it's a pre-release
          if [ "${{ github.ref_name }}" = "main" ]; then
            IS_PRERELEASE="false"
          else
            IS_PRERELEASE="true"
          fi

          # For cron builds, use fixed daily tag
          if [ "${{ steps.build_type.outputs.type }}" = "cron" ]; then
            RELEASE_TAG="daily-${RELEASE_DATE}"
            RELEASE_NAME="Daily Build ${RELEASE_DATE}"
            if [ "$IS_PRERELEASE" = "true" ]; then
              RELEASE_NAME="Daily Build ${RELEASE_DATE} (${GITHUB_REF_NAME})"
            fi
          else
            # For push/manual builds, use timestamp tag
            RELEASE_TAG="v${RELEASE_DATE}-${RELEASE_TIME}"
            if [ "$IS_PRERELEASE" = "false" ]; then
              RELEASE_NAME="Release ${RELEASE_DATE}"
            else
              RELEASE_NAME="Pre-release ${RELEASE_DATE} (${GITHUB_REF_NAME})"
            fi
          fi

          echo "tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
          echo "prerelease=${IS_PRERELEASE}" >> $GITHUB_OUTPUT
          echo "date=${RELEASE_DATE}" >> $GITHUB_OUTPUT
          echo "time=${RELEASE_TIME}" >> $GITHUB_OUTPUT

      - name: Generate changelog (for push builds)
        if: steps.build_type.outputs.type == 'push'
        id: changelog
        run: |
          # Get the last release tag
          LAST_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "")

          if [ -z "$LAST_TAG" ]; then
            echo "No previous release found, generating full changelog"
            CHANGELOG=$(git log --pretty=format:"- %s (%h) - %an" --no-merges)
          else
            echo "Generating changelog since $LAST_TAG"
            CHANGELOG=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h) - %an" --no-merges)
          fi

          # Save changelog to file
          if [ -n "$CHANGELOG" ]; then
            echo "### ðŸ“ Changelog" > changelog.md
            echo "" >> changelog.md
            echo "$CHANGELOG" >> changelog.md
            echo "" >> changelog.md
          else
            echo "### ðŸ“ Changelog" > changelog.md
            echo "" >> changelog.md
            echo "No new commits since last release." >> changelog.md
            echo "" >> changelog.md
          fi

          echo "Changelog generated:"
          cat changelog.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create release body (push builds)
        if: steps.build_type.outputs.type == 'push'
        run: |
          cat > release_body.md << 'EOF'
          ## ðŸš€ Raspberry Pi Hybrid Images - ${{ steps.release_info.outputs.date }}

          Raspberry Pi images with RaspiOS boot + Debian ARM64 rootfs.

          ### ðŸ“¦ Available Images

          All images in this release are ready to flash to SD/SSD.

          EOF

          # Add changelog if it exists
          if [ -f changelog.md ]; then
            cat changelog.md >> release_body.md
          fi

          cat >> release_body.md << 'EOF'

          ### ðŸ“ Flash an Image

          ```bash
          # Decompress and flash
          xz -dc rpi-*.img.xz | sudo dd of=/dev/sdX bs=4M status=progress conv=fsync
          sync
          ```

          **âš ï¸ Replace `/dev/sdX` with your device!**

          ### ðŸ”§ Build Info

          - **Branch** : `${{ github.ref_name }}`
          - **Commit** : `${{ github.sha }}`
          - **Date** : `${{ steps.release_info.outputs.date }}`
          - **Workflow** : [Build #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ### ðŸ“š Documentation

          See [README.md](https://github.com/${{ github.repository }}/blob/${{ github.ref_name }}/README.md) for more information.
          EOF

      - name: Create release body (cron/manual builds)
        if: steps.build_type.outputs.type != 'push'
        run: |
          cat > release_body.md << 'EOF'
          ## ðŸš€ Raspberry Pi Hybrid Images - Daily Build

          Raspberry Pi images with RaspiOS boot + Debian ARM64 rootfs.

          **ðŸ• Last updated:** `${{ steps.release_info.outputs.date }}` at `${{ steps.release_info.outputs.time }}`

          ### ðŸ“¦ Available Images

          All images in this release are ready to flash to SD/SSD.

          ### ðŸ“ Flash an Image

          ```bash
          # Decompress and flash
          xz -dc rpi-*.img.xz | sudo dd of=/dev/sdX bs=4M status=progress conv=fsync
          sync
          ```

          **âš ï¸ Replace `/dev/sdX` with your device!**

          ### ðŸ”§ Build Info

          - **Branch** : `${{ github.ref_name }}`
          - **Last Commit** : `${{ github.sha }}`
          - **Build Date** : `${{ steps.release_info.outputs.date }}` at `${{ steps.release_info.outputs.time }}`
          - **Workflow** : [Build #${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ### ðŸ“š Documentation

          See [README.md](https://github.com/${{ github.repository }}/blob/${{ github.ref_name }}/README.md) for more information.
          EOF

      - name: Update existing release (cron builds)
        if: steps.build_type.outputs.type == 'cron'
        run: |
          # Check if release exists
          if gh release view ${{ steps.release_info.outputs.tag }} >/dev/null 2>&1; then
            echo "Release ${{ steps.release_info.outputs.tag }} exists, updating..."

            # Delete old assets
            echo "Deleting old assets..."
            gh release view ${{ steps.release_info.outputs.tag }} --json assets --jq '.assets[].name' | while read asset; do
              echo "Deleting $asset"
              gh release delete-asset ${{ steps.release_info.outputs.tag }} "$asset" --yes || true
            done

            # Upload new assets
            echo "Uploading new assets..."
            gh release upload ${{ steps.release_info.outputs.tag }} *.img.xz --clobber

            # Update release notes
            echo "Updating release notes..."
            gh release edit ${{ steps.release_info.outputs.tag }} \
              --notes-file release_body.md \
              --title "${{ steps.release_info.outputs.name }}"

            echo "âœ… Release ${{ steps.release_info.outputs.tag }} updated successfully"
          else
            echo "Release ${{ steps.release_info.outputs.tag }} does not exist, creating..."
            PRERELEASE_FLAG=""
            if [ "${{ steps.release_info.outputs.prerelease }}" = "true" ]; then
              PRERELEASE_FLAG="--prerelease"
            fi

            gh release create ${{ steps.release_info.outputs.tag }} \
              --title "${{ steps.release_info.outputs.name }}" \
              --notes-file release_body.md \
              $PRERELEASE_FLAG \
              *.img.xz

            echo "âœ… Release ${{ steps.release_info.outputs.tag }} created successfully"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create new release (push/manual builds)
        if: steps.build_type.outputs.type != 'cron'
        run: |
          PRERELEASE_FLAG=""
          if [ "${{ steps.release_info.outputs.prerelease }}" = "true" ]; then
            PRERELEASE_FLAG="--prerelease"
          fi

          gh release create ${{ steps.release_info.outputs.tag }} \
            --title "${{ steps.release_info.outputs.name }}" \
            --notes-file release_body.md \
            $PRERELEASE_FLAG \
            *.img.xz

          echo "âœ… Release ${{ steps.release_info.outputs.tag }} created successfully"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          
      - name: Cleanup
        if: always()
        run: |
          # Clean up large files
          sudo rm -f *.img *.img.xz *.raw *.iso
          df -h